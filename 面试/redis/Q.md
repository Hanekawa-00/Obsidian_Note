# Redis 持久化策略
## RDB（快照）
>定期将内存数据全量快照到磁盘。优点是文件小、恢复快；缺点是可能丢失上次快照后的数据。

 在指定的时间间隔（这个时间间隔一般比AOF长得多，因为复制整个数据库非常消耗性能）内，或者当满足一定的写操作条件时，Redis 会将**当前时刻内存中的所有数据**生成一个快照（snapshot），并将其保存到一个二进制的 dump 文件（默认是 `dump.rdb`）中。
### 触发方式
主要有两种：
1. **手动触发：** 执行 `SAVE` (阻塞) 或 `BGSAVE` (非阻塞) 命令。
2. **自动触发：** 根据 `redis.conf` 中 `save <seconds> <changes>` 配置的策略，在指定时间内发生指定数量的写操作时自动触发 `BGSAVE`。
其他：
- 主从复制时，从节点初次同步执行全量同步时主节点会执行`BGSAVE`命令生成RDB文件发送至从节点。
- 执行`FLUSHALL`清空数据库时会自动触发RDB（如果配置了）。
---
## AOF（Append Only File）
>记录所有**写命令**到文件。优点是数据更安全（丢失少）；缺点是文件可能较大、恢复相对较慢。

Redis 会将接收到的**每一条写命令**（如 SET, DEL, INCR 等，读命令不会记录）以追加（append）的方式写入到一个文件（默认是 `appendonly.aof`）的末尾。当 Redis 重启时，它会重新执行 AOF 文件中保存的所有写命令，从而恢复数据。
### 工作流程
1. 客户端发送写命令（如 `SET key value`）。
2. Redis 服务器执行命令，并将数据写入内存。
3. Redis 将这条写命令追加到 AOF 缓冲区（in-memory buffer）。
4. 根据配置的同步策略 (`appendfsync` 配置项)，将 AOF 缓冲区的内容写入（`write()`) 到 AOF 文件并同步 (`fsync()`) 到磁盘。
### appendfsync策略
- `always`: **每执行一条写命令**就立即同步到磁盘。最安全，几乎不丢数据，但性能开销最大，严重影响 Redis 吞吐量。
- `everysec` (默认): **每秒钟同步**一次。这是一个很好的折中，性能较好，即使宕机，最多只会丢失上一秒内的数据。
- `no`: 完全依赖操作系统来决定何时同步。速度最快，但数据安全性最低，宕机可能丢失较多数据。
### AOF重写机制（AOF Rewrite）
>为了解决aof文件不断追加命令而变得过大的问题，减小磁盘占用，以及加快恢复速度。

**实现：**
1. Redis `fork` 一个子进程，该子进程读取当前内存中的数据状态，生成能够恢复这些数据的最小化命令集，写入新的临时 AOF 文件。
2. 对于在生成新的AOF文件期间产生的写命令会存到**重写缓冲区**中，待新的AOF创建完成会追加到文件末尾。
3. 然后原子地替换旧AOF文件。
---
## 同时开启两种持久化策略时，默认使用哪个文件来恢复
>会**优先加载 AOF 文件**来恢复数据。因为 AOF 文件通常能提供更完整的数据（丢失更少）。只有在 AOF 关闭或 AOF 文件不存在/损坏时，才会尝试加载 RDB 文件
---
## 持久化对Redis性能的影响
- **RDB:** `BGSAVE` 主要影响在于 `fork()` 操作，它可能导致短暂的 CPU 飙升和内存占用增加（写时复制机制）。数据量越大，影响越明显。**磁盘 I/O** 由子进程负责，对**主进程影响较小**。
- **AOF:**
    - 写命令追加到 AOF 缓冲区是很快的。
    - 主要影响在于 `fsync` 同步操作。`always` 策略对 QPS 影响最大；`everysec` 影响较小；`no` 几乎无影响。
    - AOF 重写也涉及 `fork()` 和磁盘 I/O，影响类似于 `BGSAVE`。
---
## 混合持久化？
-  在 AOF 重写时，新的 AOF 文件不再是纯粹的命令序列。它会先将当前内存数据以 **RDB 格式**写入 AOF 文件的开头，然后将**重写期间**产生的增量写命令以 **AOF 格式**追加在 RDB 内容的后面。
- **优点：** 结合了 RDB 和 AOF 的优点。加载时，先加载 RDB 部分快速恢复大部分数据，然后加载 AOF 部分恢复增量数据。这样既能保证数据恢复速度快，又能获得 AOF 的高数据安全性。
--- 
## 各有什么优缺点
**RDB**：
- **优点**：
	- 生成的文件是压缩过的**二进制格式，体积小**，非常适合用于备份。
	- 恢复数据时，直接加载 RDB 文件即可，速度比 AOF 快，适合灾难恢复。
	- 对 Redis 性能影响较小（子进程进行 IO 操作，主进程影响不大，主要是 `fork()` 时刻）。
- **缺点**：
	- **不是实时持久化**。如果两次快照之间 Redis 宕机，那么这期间修改的数据会全部丢失。丢失的数据量取决于快照的频率（例如，配置为每 5 分钟生成一次快照，那最多可能丢失近 5 分钟的数据）。
	- `fork()` 操作在数据量很大时会比较耗时，且会消耗额外的内存（虽然有写时复制 Copy-on-Write 优化，但在写操作频繁时仍可能消耗较多内存）。
**AOF**：
- **优点**：
	- 数据安全性更高。根据 `appendfsync` 策略，可以做到丢失很少（最多 1 秒）甚至不丢失数据。
	- AOF 文件是追加写入，即使文件写入不完整（如磁盘满了），也可以用 `redis-check-aof` 工具修复。
	- AOF 文件内容是协议文本，可读性较好（虽然不是设计给人直接读的）。
- **缺点**：
	- 对于相同的数据集，AOF 文件通常比 RDB 文件大很多。
	- 恢复数据时需要重新执行所有命令，速度通常比 RDB 慢。
---
## 二者如何选择
- 如果要求可以快速恢复的场景下，可以选择RDB策略，它的回复速度比AOF快得多。但是要能接受数据一致性问题，也就是几分钟之内的数据丢失。
- 如果要求高数据一致性、实时性的场景下，建议选择AOF策略，它的数据集完整性较高，通常只会丢失数秒的数据或者不丢失数据。但是恢复速度较慢。
---
# 主从复制
## 应用场景
1. **单点故障 (Single Point of Failure, SPOF):** 单个 Redis 实例一旦宕机，整个服务就不可用，可能导致业务中断。（高可用）
2. **读压力过大:** 如果所有读写请求都集中在一个 Redis 实例上，当读请求量非常大时，单个实例可能无法承受，导致响应变慢。（高并发）
---
1. **高可用 (High Availability, HA):** 当主节点（Master）发生故障时，可以快速将一个从节点（Slave/Replica）提升为新的主节点，继续提供服务，大大缩短服务中断时间。这是构建 Redis Sentinel 和 Redis Cluster 的基础。
2. **读写分离 (Read/Write Splitting):** 主节点负责处理写请求和一部分读请求，而将大部分读请求分散到多个从节点上处理，从而提高整个系统的读并发能力和吞吐量。
# 基础
## MySQL性能差的原因
- 为使用索引进行优化
- 查询数据量过多（如全表扫描）
- CPU等硬件资源瓶颈
- SQL语句过于复杂
### Q 
- 使用索引优化
- 添加Redis等缓存
---
## 多表合并查询
1. **Q: 内连接和左外连接有什么区别？举例说明。**
    - **A:** 内连接只返回两个表都匹配的行（交集），左外连接返回左表所有行以及右表匹配的行（左表为主）。举例：查询“哪些客户下过订单”用内连接；查询“所有客户及其订单（即使没下过订单）”用左外连接。
2. **Q: 什么时候用右外连接？它和左外连接能互相转换吗？**
    - **A:** 右外连接以右表为主，返回右表所有行及左表匹配行。例如，查询“所有订单及其对应客户（即使客户不存在）”。左右外连接可以互相转换，只需交换 FROM 和 JOIN 后面的表位置即可。
3. **Q: 交叉连接有什么用？在实际中常用吗？**
    - **A:** 交叉连接返回笛卡尔积，通常不直接用于常规数据查询，因为它结果集巨大。常见用途：生成所有可能的组合（如生成所有商品和所有仓库的组合）、测试数据生成。
4. **Q: 如何优化 JOIN 操作的性能？**
    - **A:**
        - **在连接列上创建索引：** 这是最重要的优化手段。
        - **选择合适的连接类型：** 避免不必要的全表扫描。
        - **优化连接顺序：** 数据库会尝试优化，但有时手动调整 FROM 后面的表顺序（小表在前）可能有效。
        - **减少连接的表数量：** 如果可能，避免连接过多表。
        - **使用小表驱动大表：** 在某些场景下，让结果集较小的表先进行筛选，再与大表连接。
5. **Q: 为什么 MySQL 不直接支持 FULL OUTER JOIN？如何模拟？**
    - **A:** MySQL 早期版本设计如此。模拟方法是使用 LEFT JOIN 和 RIGHT JOIN 的结果集通过 UNION 操作合并。UNION 会自动去重。

![[sql.svg]]
## 三大范式
1. **第一范式 (1NF)：**
    - **原理：** 确保数据库表中的每一列都是 **原子性的**，不可再分。
    - **比喻：** 就像你的 Excel 表格里，一个单元格不能包含多个值。比如，“联系电话”列不能同时写“家里电话: 123, 手机: 456”，而是应该拆分成“家里电话”和“手机”两列，或者更进一步，创建一个单独的“联系方式”表。
    - **要求：** ==每列的值都是不可分割的最小单元。==
    - **示例（不符合 1NF）：** 一个“学生课程成绩”表，其中有一列是“课程列表”，值为“数学, 物理, 英语”。
    - **示例（符合 1NF）：** 将“课程列表”拆分成多行，每行只包含一门课程的信息。
2. **第二范式 (2NF)：**
    - **原理：** 在满足 1NF 的基础上，非主键列必须 **完全依赖于主键**，而不是主键的一部分。
    - **比喻：** 就像你的 Excel 表格，如果你的主键是“学号 + 课程ID”，那么学生的姓名、班级等信息（非主键列）应该只依赖于“学号”（主键的一部分），而不是同时依赖于“学号 + 课程ID”。如果学生姓名依赖于“学号 + 课程ID”，那就意味着同一个学生选不同课时，他的姓名可能会重复存储，且修改名字时需要在多处修改。
    - **要求：** 满足 1NF；非主键列必须完全函数依赖于主键。
    - **示例（不符合 2NF）：** “学生选课成绩”表 (学号, 课程ID, 学生姓名, 课程名称, 成绩)。主键是 (学号, 课程ID)。学生姓名只依赖于学号，课程名称只依赖于课程ID，它们没有完全依赖于联合主键 (学号, 课程ID)。
    - **示例（符合 2NF）：** 将表拆分成三个表：
        - `学生表` (学号, 学生姓名, 班级) - 主键：学号
        - `课程表` (课程ID, 课程名称) - 主键：课程ID
        - `选课成绩表` (学号, 课程ID, 成绩) - 主键：(学号, 课程ID)，外键：学号引用学生表，课程ID引用课程表。 这样，学生姓名只存储在学生表中，课程名称只存储在课程表中，避免了冗余和更新异常。
3. **第三范式 (3NF)：**
    - **原理：** 在满足 2NF 的基础上，非主键列之间 **不能存在传递依赖**(同一个表中存在其他主键依赖)。也就是说，==非主键列不能依赖于另一个非主键列。==
    - **比喻：** 就像你的 Excel 表格，如果你的主键是“学号”，非主键列有“班级编号”和“班主任姓名”。如果班主任姓名只依赖于班级编号（而不是直接依赖于学号），那么就存在传递依赖：学号 -> 班级编号 -> 班主任姓名。这意味着同一个班级的所有学生都会重复存储班主任姓名，且班主任换人时需要在多处修改。
    - **要求：** 满足 2NF；任何非主键列都不对非主键列具有传递依赖。
    - **示例（不符合 3NF）：** 在符合 2NF 的 `学生表` 中 (学号, 学生姓名, 班级编号, 班主任姓名)。主键是学号。班主任姓名依赖于班级编号，班级编号依赖于学号 (学号 -> 班级编号 -> 班主任姓名)。
    - **示例（符合 3NF）：** 将表拆分成两个表：
        - `学生表` (学号, 学生姓名, 班级编号) - 主键：学号，外键：班级编号引用班级表。
        - `班级表` (班级编号, 班主任姓名) - 主键：班级编号。 这样，==班主任姓名只存储在班级表中，避免了冗余和更新异常。==
---
1. **Q: 什么是数据库三大范式？各自解决什么问题？**
    
    - **A:** 范式是数据库设计原则，用于减少冗余和异常。1NF 要求列原子化；2NF 要求非主键完全依赖主键；3NF 要求非主键无传递依赖。分别解决列不可分、部分依赖、传递依赖带来的冗余和异常。
2. **Q: 为什么有时要“反范式”设计？会带来什么问题？**
    
    - **A:** 反范式是为了提高查询性能，通过增加冗余来减少 JOIN 操作。例如，在订单表中存储冗余的客户姓名，查询时无需连接客户表。问题：增加数据冗余、更新异常风险、维护成本高。提示：在面试中，强调“范式与性能的权衡”。
3. **Q: 如何判断一个表是否符合某个范式？**
    
    - **A:** 检查是否满足该范式及之前所有范式的要求。例如，判断是否符合 3NF，先看是否符合 1NF、2NF，再看是否存在传递依赖。
4. **Q: 数据库设计到哪个范式比较合适？**
    
    - **A:** 通常到 3NF 是一个很好的平衡点，既减少了冗余，又不会导致表过多、连接过于复杂。BCNF 更严格，但在一些场景可能引入新的复杂性。
5. **Q: 在实际项目中，你是如何进行数据库设计的？**
    
    - **A:** （结合范式和实际经验回答）先进行需求分析，识别实体和关系 -> 遵循范式原则设计表结构（通常到 3NF）-> 考虑业务场景和性能需求，可能进行适当的反范式优化 -> 定义主键、外键、索引 -> 进行数据库建模和评审。
下面从“构建会话工厂（SqlSessionFactory）”和“会话（SqlSession）运行”两个方面，简要介绍 MyBatis 的工作原理。

────────────────────────────────────────────────────────
一、构建会话工厂（SqlSessionFactory）的过程
────────────────────────────────────────────────────────
1. 解析配置信息  
   • MyBatis 会先读取核心配置文件（一般是 mybatis-config.xml）或基于 Java Config 的配置信息，该配置文件包含数据库连接信息、事务管理、全局设置信息等。  
   • MyBatis 同时加载需要注册的 Mapper 映射文件（XXXMapper.xml）或扫描注解方式的 Mapper 接口。  

2. 建立 Configuration 对象  
   • 经由 XMLConfigBuilder 或者 Java Config Builder 之类的解析器将配置文件解析为内部的 Configuration 对象。  
   • Configuration 会持有全局配置内容，比如数据源（DataSource）、事务管理器（TransactionFactory）、类型别名、插件等信息。  
   • 同时会将 Mapper 映射文件中定义的 SQL 语句（select、insert、update、delete）解析生成 MappedStatement 对象，并存储在 Configuration 中。

3. 创建 SqlSessionFactory  
   • 解析完成后，会通过 SqlSessionFactoryBuilder.build(...) 方法，基于 Configuration 创建出一个 SqlSessionFactory 对象。  
   • SqlSessionFactory 是单例或多例取决于你的设计与容器管理方式，但通常在应用中是单例（全局只创建一次）。

────────────────────────────────────────────────────────
二、会话（SqlSession）的运行过程
────────────────────────────────────────────────────────
1. 打开 SqlSession  
   • 应用程序在需要与数据库交互时，通过 SqlSessionFactory.openSession() 获取一个新的 SqlSession 示例。  
   • 每个 SqlSession 都会关联一个 Executor（执行器），执行器内部负责实际执行映射语句、处理缓存、增删改查等逻辑。

2. 执行数据库操作  
   • 应用可以直接使用 SqlSession 提供的增删改查方法（如 selectList、selectOne、insert、update、delete 等），也可以调用 Mapper 映射接口（基于 Mapper 动态代理机制）。  
   • Mapper 接口调用时，MyBatis 会通过 MapperProxy 动态生成实现类，并解析调用的方法和参数，找到对应的 MappedStatement，然后交给 Executor 进行执行。

3. 执行器（Executor）的工作流程  
   1) 生成或拼接 SQL 语句：MyBatis 会基于映射文件中的 SQL 标签和动态 SQL（if、choose、foreach 等）来生成最终要执行的 SQL 文本。  
   2) 参数处理：ParameterHandler 根据方法参数和配置（#{}、${} 等），准备出最终的 JDBC 参数。  
   3) 缓存检查：Executor 先检查一级缓存（SqlSession 级）或二级缓存（命名空间级/Mapper 级）中是否存在可用的结果集。如果命中则直接返回，否则继续向下执行。  
   4) 执行 SQL：通过 StatementHandler 把 SQL 交给底层 JDBC 或数据源进行实际执行（查询 / 更新 / 删除 / 插入）。  
   5) 结果映射：ResultSetHandler 将结果集映射为 Java 对象（如 POJO、List 等），如果开启了驼峰映射等特性，则会对数据列与对象属性进行对应转换。  
   6) 缓存更新：如果结果要缓存（开启了二级缓存或其他缓存策略），则将查询结果放入缓存。增删改操作会清空或刷新对应的缓存。

4. 事务管理  
   • 如果使用了 MyBatis 自带的事务管理器或在 Spring 中整合，SqlSession 会在事务提交或回滚时自动处理相应的事务逻辑。  
   • 在手动管理事务时，需要显式调用 sqlSession.commit() 或 sqlSession.rollback() 来提交或回滚事务，并释放连接。

5. 关闭 SqlSession  
   • 数据库操作完成后，应该关闭 SqlSession（或者在 Spring 集成场景，由框架管理 SqlSession 的关闭），以释放资源并确保一级缓存不被意外重用。  

────────────────────────────────────────────────────────
三、简要工作原理小结
────────────────────────────────────────────────────────
• “构建阶段”：通过解析 MyBatis 配置和 Mapper 文件，创建 Configuration 和一系列 MappedStatement，最终构建出 SqlSessionFactory。  
• “执行阶段”：应用使用 SqlSessionFactory.openSession() 获取会话，调用 Mapper 方法或 SqlSession 方法，通过 Executor 处理 SQL、缓存、数据映射等，并最终返回 Java 对象或更新数据库。  
• 事务和缓存策略：MyBatis 内置了多种事务管理模式和两级缓存策略，能够灵活定制数据访问层的执行效率和一致性需求。  

总的来说，MyBatis 通过在“构建会话工厂”和“会话运行”两个阶段分工，既实现了配置与运行时逻辑的解耦，也在查询执行中利用缓存、插件、动态 SQL 等特性有效提升数据访问的灵活性和性能。
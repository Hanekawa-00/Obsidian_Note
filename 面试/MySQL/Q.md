# 基础
## MySQL性能差的原因
- 为使用索引进行优化
- 查询数据量过多（如全表扫描）
- CPU等硬件资源瓶颈
- SQL语句过于复杂
### Q 
- 使用索引优化
- 添加Redis等缓存
---
## 多表合并查询
1. **Q: 内连接(inner join)和左外连接(left join)有什么区别？举例说明。**
    - **A:** 内连接只返回两个表都匹配的行（交集），左外连接返回左表所有行以及右表匹配的行（左表为主）。举例：查询“哪些客户下过订单”用内连接；查询“所有客户及其订单（即使没下过订单）”用左外连接。
2. **Q: 什么时候用右外连接？它和左外连接能互相转换吗？**
    - **A:** 右外连接以右表为主，返回右表所有行及左表匹配行。例如，查询“所有订单及其对应客户（即使客户不存在）”。左右外连接可以互相转换，只需交换 FROM 和 JOIN 后面的表位置即可。
3. **Q: 交叉连接有什么用？在实际中常用吗？**
    - **A:** 交叉连接返回笛卡尔积，通常不直接用于常规数据查询，因为它结果集巨大。常见用途：生成所有可能的组合（如生成所有商品和所有仓库的组合）、测试数据生成。
4. **Q: 如何优化 JOIN 操作的性能？**
    - **A:**
        - **在连接列上创建索引：** 这是最重要的优化手段。
        - **选择合适的连接类型：** 避免不必要的全表扫描。
        - **优化连接顺序：** 数据库会尝试优化，但有时手动调整 FROM 后面的表顺序（小表在前）可能有效。
        - **减少连接的表数量：** 如果可能，避免连接过多表。
        - **使用小表驱动大表：** 在某些场景下，让结果集较小的表先进行筛选，再与大表连接。
5. **Q: 为什么 MySQL 不直接支持 FULL OUTER JOIN？如何模拟？**
    - **A:** MySQL 早期版本设计如此。模拟方法是使用 LEFT JOIN 和 RIGHT JOIN 的结果集通过 UNION 操作合并。UNION 会自动去重。

![[sql.svg]]
## 三大范式
1. **第一范式 (1NF)：**
    - **原理：** 确保数据库表中的每一列都是 **原子性的**，不可再分。
    - **比喻：** 就像你的 Excel 表格里，一个单元格不能包含多个值。比如，“联系电话”列不能同时写“家里电话: 123, 手机: 456”，而是应该拆分成“家里电话”和“手机”两列，或者更进一步，创建一个单独的“联系方式”表。
    - **要求：** ==每列的值都是不可分割的最小单元。==
    - **示例（不符合 1NF）：** 一个“学生课程成绩”表，其中有一列是“课程列表”，值为“数学, 物理, 英语”。
    - **示例（符合 1NF）：** 将“课程列表”拆分成多行，每行只包含一门课程的信息。
2. **第二范式 (2NF)：**
    - **原理：** 在满足 1NF 的基础上，非主键列必须 **完全依赖于主键**，而不是主键的一部分。
    - **比喻：** 就像你的 Excel 表格，如果你的主键是“学号 + 课程ID”，那么学生的姓名、班级等信息（非主键列）应该只依赖于“学号”（主键的一部分），而不是同时依赖于“学号 + 课程ID”。如果学生姓名依赖于“学号 + 课程ID”，那就意味着同一个学生选不同课时，他的姓名可能会重复存储，且修改名字时需要在多处修改。
    - **要求：** 满足 1NF；非主键列必须完全函数依赖于主键。
    - **示例（不符合 2NF）：** “学生选课成绩”表 (学号, 课程ID, 学生姓名, 课程名称, 成绩)。主键是 (学号, 课程ID)。学生姓名只依赖于学号，课程名称只依赖于课程ID，它们没有完全依赖于联合主键 (学号, 课程ID)。
    - **示例（符合 2NF）：** 将表拆分成三个表：
        - `学生表` (学号, 学生姓名, 班级) - 主键：学号
        - `课程表` (课程ID, 课程名称) - 主键：课程ID
        - `选课成绩表` (学号, 课程ID, 成绩) - 主键：(学号, 课程ID)，外键：学号引用学生表，课程ID引用课程表。 这样，学生姓名只存储在学生表中，课程名称只存储在课程表中，避免了冗余和更新异常。
3. **第三范式 (3NF)：**
    - **原理：** 在满足 2NF 的基础上，非主键列之间 **不能存在传递依赖**(同一个表中存在其他主键依赖)。也就是说，==非主键列不能依赖于另一个非主键列。==
    - **比喻：** 就像你的 Excel 表格，如果你的主键是“学号”，非主键列有“班级编号”和“班主任姓名”。如果班主任姓名只依赖于班级编号（而不是直接依赖于学号），那么就存在传递依赖：学号 -> 班级编号 -> 班主任姓名。这意味着同一个班级的所有学生都会重复存储班主任姓名，且班主任换人时需要在多处修改。
    - **要求：** 满足 2NF；任何非主键列都不对非主键列具有传递依赖。
    - **示例（不符合 3NF）：** 在符合 2NF 的 `学生表` 中 (学号, 学生姓名, 班级编号, 班主任姓名)。主键是学号。班主任姓名依赖于班级编号，班级编号依赖于学号 (学号 -> 班级编号 -> 班主任姓名)。
    - **示例（符合 3NF）：** 将表拆分成两个表：
        - `学生表` (学号, 学生姓名, 班级编号) - 主键：学号，外键：班级编号引用班级表。
        - `班级表` (班级编号, 班主任姓名) - 主键：班级编号。 这样，==班主任姓名只存储在班级表中，避免了冗余和更新异常。==
---
1. **Q: 什么是数据库三大范式？各自解决什么问题？**
    
    - **A:** 范式是数据库设计原则，用于减少冗余和异常。1NF 要求列原子化；2NF 要求非主键完全依赖主键；3NF 要求非主键无传递依赖。分别解决列不可分、部分依赖、传递依赖带来的冗余和异常。
2. **Q: 为什么有时要“反范式”设计？会带来什么问题？**
    
    - **A:** 反范式是为了提高查询性能，通过增加冗余来减少 JOIN 操作。例如，在订单表中存储冗余的客户姓名，查询时无需连接客户表。问题：增加数据冗余、更新异常风险、维护成本高。提示：在面试中，强调“范式与性能的权衡”。
3. **Q: 如何判断一个表是否符合某个范式？**
    
    - **A:** 检查是否满足该范式及之前所有范式的要求。例如，判断是否符合 3NF，先看是否符合 1NF、2NF，再看是否存在传递依赖。
4. **Q: 数据库设计到哪个范式比较合适？**
    
    - **A:** 通常到 3NF 是一个很好的平衡点，既减少了冗余，又不会导致表过多、连接过于复杂。BCNF 更严格，但在一些场景可能引入新的复杂性。
5. **Q: 在实际项目中，你是如何进行数据库设计的？**
    
    - **A:** （结合范式和实际经验回答）先进行需求分析，识别实体和关系 -> 遵循范式原则设计表结构（通常到 3NF）-> 考虑业务场景和性能需求，可能进行适当的反范式优化 -> 定义主键、外键、索引 -> 进行数据库建模和评审。
## IN和EXISTS子查询
>这种查询一般只是判断数据是否存在的查询方法，要得到复杂的数据还是使用`join`合并查询
1. **`IN` 的原理：**
    - **执行过程：** 通常情况下，数据库会==先执行子查询，生成一个结果集列表==（例如，所有下过订单的客户 ID 列表）。然后，数据库遍历外层查询的每一行，检查该行中用于匹配的列值（例如，客户 ID）是否存在于子查询生成的结果集列表中，存在则添加到返回结果中。
    - **实例：** 就像你拿到一份“所有下过订单的客户 ID”的清单（子查询结果集），然后挨个核对“客户名单”上的每一个客户，看看他们的 ID 是否在你的清单上。如果在，就把这个客户的信息挑出来。
    - **特点：** 子查询会执行一次，生成一个完整的列表。适用于子查询结果集较小的情况。
2. **`EXISTS` 的原理：**
    - **执行过程：** `EXISTS` 子查询通常是 **关联子查询**。数据库会==遍历外层查询的每一行。对于外层查询的每一行，都会执行一次子查询。子查询会判断是否存在与当前外层查询行相关联的记录。==只要子查询找到匹配的 **第一行**，就会返回 TRUE，外层查询继续处理下一行；如果子查询遍历完所有相关记录都没有找到匹配的行，就返回 FALSE。
    - **实例：** 就像你拿着“客户名单”上的第一个客户，去“订单列表”里找“这个客户有没有订单”。找到了一个订单？好的，不用再找了，这个客户符合条件，把他挑出来，然后处理下一个客户。如果找遍了都没找到这个客户的订单，就放弃这个客户，处理下一个。
    - **特点：** 子查询会根据外层查询的行数执行多次。适用于子查询结果集较大，或者子查询本身包含复杂的逻辑判断（如 JOIN、WHERE）的情况。
### Q
1. **Q: IN 和 EXISTS 的主要区别是什么？**
    
    - **A:** `IN` 是将外层查询的值与子查询的结果集进行匹配，子查询通常先执行一次；`EXISTS` 是判断子查询是否返回行，子查询通常是关联子查询，对外层查询的每一行执行一次。
2. **Q: 什么时候优先使用 IN，什么时候优先使用 EXISTS？**
    
    - **A:**
        - **IN 优先：** **子查询结果集较小**，或者子查询不依赖外层查询的任何列。
        - **EXISTS 优先：** 子查询结果集较大，或者子查询依赖外层查询的列（关联子查询），且外层查询结果集相对较小。
        - **最准确判断：** 使用 `EXPLAIN` 分析查询计划，看哪种写法的执行计划更优。
3. **Q: EXISTS 后面的 SELECT 1 是什么意思？可以写 SELECT * 吗？**
    
    - **A:** `SELECT 1` 是一种约定俗成的写法，表示“只要找到任何一行就行，具体值是多少不重要”。写 `SELECT *` 也可以，但 `SELECT 1` 效率更高，因为它不需要实际去检索列的值。
4. **Q: IN 和 JOIN 能互相替代吗？有什么优缺点？**
    - **A:** 在很多情况下可以互相替代。
        - **JOIN 优点：** 可以返回两个表中的所有列，更灵活；优化器通常对 JOIN 有更好的优化。
        - **JOIN 缺点：** 在某些场景下，如果只关心是否存在，JOIN 可能会产生冗余的中间结果集，不如 EXISTS 直接。
        - **IN 优点：** 语法简洁，易于理解。
        - **IN 缺点：** 在大数据集上性能可能不如 EXISTS 或优化后的 JOIN。
        - **EXISTS 优点：** 在大数据集上可能性能更好，尤其适合判断是否存在。
        - **EXISTS 缺点：** 只能判断是否存在，不能直接获取子查询中的其他列信息。
5. **Q: IN 子查询中如果返回 NULL 值会有什么影响？**
    - **A:** 如果子查询返回的列表包含 NULL 值，那么 `WHERE column IN (..., NULL, ...)` 这样的条件可能会导致意外的结果。因为 `value IN (..., NULL, ...)` 对于任何非 NULL 的 `value` 都会判断为 UNKNOWN（未知），导致无法匹配。而 `WHERE column NOT IN (..., NULL, ...)` 对于任何值都会判断为 UNKNOWN，导致没有任何行返回。这是一个常见的陷阱。**而 `EXISTS` 子查询通常不受 NULL 值影响。**
## SQL执行顺序
```sql
SELECT DISTINCT column_list
FROM table_name 
[JOIN ...]
WHERE condition
GROUP BY grouping_column(s)
HAVING group_condition
ORDER BY sorting_column(s)
LIMIT limit_value [OFFSET offset_value];
```

1. **`FROM`**: 确定数据来源。首先，确定需要从哪些表获取数据。如果涉及多个表，会进行笛卡尔积操作（虽然优化器通常会避免直接计算完整的笛卡尔积）。
    
2. **`JOIN`**: 表连接。根据 JOIN 条件将 FROM 子句中指定的表连接起来，生成一个更大的中间结果集。
    
3. **`ON`**: JOIN 的连接条件。在 JOIN 过程中，根据 ON 子句指定的条件进行匹配。
    
4. **`WHERE`**: 行过滤。根据 WHERE 子句指定的条件，从 JOIN 生成的中间结果集中筛选出符合条件的行。**注意：** **在这个阶段，SELECT 子句中的列别名是不可用的，因为 SELECT 子句还没执行。(只是构建了语句，或者说是查询逻辑)**
    
5. **`GROUP BY`**: 分组。根据 GROUP BY 子句指定的列，将 WHERE 过滤后的结果集进行分组。
    
6. **`CUBE / ROLLUP` (可选):** 更高级的分组操作，生成更详细的聚合结果。
    
7. **`HAVING`**: 分组后过滤。对 GROUP BY 分组后的结果进行过滤。与 WHERE 不同，HAVING 可以使用聚合函数（如 COUNT(), SUM(), AVG()）作为过滤条件。
    
8. **`SELECT`**: 选择列。根据 SELECT 子句指定的列，从 HAVING 过滤后的结果集中选择需要显示的列。此时，可以在 SELECT 列表中使用列别名。
    
9. **`DISTINCT` (可选):** 去重。如果指定了 DISTINCT，则从 SELECT 选出的结果集中移除重复的行。
    
10. **`ORDER BY`**: 排序。根据 ORDER BY 子句指定的列对最终结果集进行排序。此时，可以使用 SELECT 子句中定义的列别名。
    
11. **`LIMIT / OFFSET` (或 TOP, ROWNUM 等):** 分页。根据 LIMIT 和 OFFSET 子句（或其他数据库系统的等效子句），限制返回的行数，用于实现分页。这个通常是最后执行的步骤。
### 实例

1. 假设我们有 `orders` 表: `order_id`, `user_id`, `order_amount`, `order_date`。
	**需求：** 统计每个用户(`group by user_id`)的订单总金额，只统计 2023 年的订单，并且只显示订单总金额大于 1000 元的用户，最后按总金额降序排列，取前 10 条记录。
```sql
	SELECT user_id, SUM(order_amount) AS total_amount -- 8. SELECT (选择列，可以使用聚合函数和别名)
	FROM orders -- 1. FROM (指定数据来源)
	WHERE order_date >= '2023-01-01' AND order_date < '2024-01-01' -- 4. WHERE (行过滤，发生在分组前)
	GROUP BY user_id -- 5. GROUP BY (按用户分组)
	HAVING SUM(order_amount) > 1000 -- 7. HAVING (分组后过滤，可以使用聚合函数)
	ORDER BY total_amount DESC -- 10. ORDER BY (按总金额降序排序，可以使用 SELECT 中的别名)
	LIMIT 10; -- 11. LIMIT (限制返回行数)
	```
2. **场景：** 社交平台需要找出粉丝数量超过 10000 的用户，并按粉丝数量降序显示前 50 名。
*   **问题：** 需要对用户进行分组（每个用户一组），计算粉丝总数，然后过滤，最后排序和分页。
*   **执行顺序应用：**

    假设有 `followers` 表 (follower_id, followed_user_id)。

    **需求：** 查询粉丝数大于 10000 的用户，并按粉丝数降序排列前 50 名。

    ```sql
    SELECT followed_user_id, COUNT(follower_id) AS follower_count -- 7. SELECT (选择用户ID和粉丝数)
    FROM followers -- 1. FROM (指定数据来源表)
    -- 这里没有 WHERE 子句，因为没有行级别的过滤需求
    GROUP BY followed_user_id -- 5. GROUP BY (按被关注用户分组)
    HAVING COUNT(follower_id) > 10000 -- 6. HAVING (过滤粉丝数大于10000的组)
    ORDER BY follower_count DESC -- 8. ORDER BY (按粉丝数降序排序，使用 SELECT 中的别名)
    LIMIT 50; -- 9. LIMIT (限制返回前50条)
    ```

    **执行流程：**
    1.  从 `followers` 表中获取所有数据。
    2.  将数据按 `followed_user_id` 分组。
    3.  对每个组（每个被关注用户），计算其粉丝数量 (`COUNT(follower_id)`)。
    4.  过滤掉粉丝数量小于等于 10000 的组。
    5.  选择每个符合条件的组的 `followed_user_id` 和计算出的粉丝数量。
    6.  按粉丝数量降序排列结果。
    7.  取出前 50 条记录。

    **效果：** 通过遵循 SQL 的执行顺序，我们能够清晰地表达业务逻辑，并让数据库按照高效的方式执行查询（先分组聚合，再过滤）。

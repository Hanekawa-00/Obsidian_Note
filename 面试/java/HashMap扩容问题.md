![[Pasted image 20241223092446.png]]
# 扩容机制
`HashMap` 是基于哈希表的数据结构，用于存储**键值对**（`key-value`）。其核心是将键的哈希值映射到数组索引位置，通过**数组 + 链表**（在 Java 8 及之后是**数组 + 链表 + 红黑树**）来处理哈希冲突。

`HashMap` 使用键的 `hashCode()` 方法计算哈希值，并通过 `indexFor` 方法（JDK 1.7 及之后版本移除了这个方法，直接使用 `(n - 1) & hash`）确定元素在数组中的存储位置。哈希值是经过一定扰动处理的，防止哈希值分布不均匀，从而减少冲突。

`HashMap` 的默认初始容量为 16，负载因子为 0.75。也就是说，当存储的元素数量超过 16 × 0.75 = 12 个时，`HashMap` 会触发扩容操作，容量x2并重新分配元素位置。这种扩容是比较耗时的操作，频繁扩容会影响性能。
# 多线程条件下的问题
## 数据覆盖
当多个线程同时尝试向 `HashMap` 中插入键值对，并且恰好这些键的哈希值相同（或落在同一个哈希桶中）时，就可能发生数据覆盖。
## 死循环
在 `HashMap` 的 `resize()` 过程中，需要将旧数组中的元素转移到新数组中。这个过程涉及到链表的反转。在单线程环境下，这个过程没有问题。但是在多线程环境下，由于多个线程同时操作链表，可能会导致链表中的节点互相指向，形成循环链表。
## 数据不一致
在同时读写时会出现数据不一致的情况

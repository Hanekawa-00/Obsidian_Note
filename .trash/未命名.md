# Java并发编程

## 基础

### 并行与并发
- **并行**: 同一时刻有两个线程在执行，需要有两个CPU内核
- **并发**: 在同一时刻只有一个线程在执行，但是CPU在极短的时间内快速切换线程，在一个时间段中可以执行多个线程。

### 进程与线程
- **进程**: 系统进行资源分配的基本单位
- **线程**: CPU分配的基本单位
- 操作系统将资源分配给进程，而一个进程中有一个或多个线程，这些线程又由CPU来调度

### 几种线程创建方式
- 继承Thread类，重写run()方法
- 实现Runnable接口，实现run()方法
- 实现Callable接口，重写call()方法，可以使用FutureTask获取执行任务的返回值

### start()和run()方法
- 只有在调用start()方法时，才会创建一个线程来执行run()中的内容

### 线程的几种调度方式
- **等待**: wait()和join()方法
    - 调用Object类的wait()方法时，线程会被阻塞挂起
    - Thread类中提供了join()方法，使当前线程等待调用join()方法的那个线程
- **通知**: notify()和notifyAll()方法，唤醒正在被wait()挂起的线程
- **休眠**: Thread类中的静态sleep()方法
    - 线程让出一定时间CPU的执行权，但是所占用的资源不会被让出，比如说锁。达到一定时间后接着参与CPU调度。
- **中断**: interrupt()、isInterrupted()、interrupted()
    - 只是放出一个标志来告诉程序这个线程要中断，但是一般是根据isInterrupted()方法来判断是否要终止线程，然后做一些业务逻辑处理再通过抛出异常、使用interrupted()方法来重置标志为false等手段来中止线程。
- **让出优先级**: yield()
    - 一个线程调用此方法后，按时线程调度器请求让出自己的CPU，但是线程调度器可以无条件忽略

### 线程的6种状态
- **NEW** 初始状态
    - 线程被创建（new Thread()），但是并没有调用start()方法
- **RUNNABLE** 运行状态(就绪+运行)
    - Java线程中就绪和运行两种状态笼统地称为运行状态
- **BLOCKED** 阻塞
    - 线程阻塞于锁(注意这里被锁阻塞才是BOLOCKED状态)，需要等待锁地释放
- **WAITING** 等待
    - 线程进入等待状态（调用wait()、join()等方法），等待唤醒继续执行
- **TIME_WAITING** 超时等待
  - 在指定时间自行唤醒
- **TERMINATED** 终止
  - 表示线程已经执行完毕

### 线程上下文切换
- 所谓地线程上下文切换就是高效利用CPU以达到多线程的效果，可以让用户感觉是多个线程同时执行，这依赖于CPU的时间片轮转调度：操作系统将CPU的时间分为多个时间片，多个线程轮流占用CPU执行，当线程使用完时间片后（此时线程没有进入终止状态，说不定待会还要继续执行）就会处于就绪状态并让出CPU让其他线程占用，之后再拿到时间片后还可继续执行未完成的线程任务，而这个过程就是线程上下文切换。

### 守护线程
- 守护线程（Daemon Thread）是Java中的一种特殊线程，与用户线程（User Thread）相对应。它主要用于在后台提供通用服务，比如垃圾回收、日志记录等。

### 线程间的通信方式
- 等待/通知机制（wait()/notify()），还有join()方法来通知当前线程需要等待另一个线程的结束
- 使用volatile和synchronized关键字保证可见性和原子性
- 管道输入/输出流
- ThreadLocal，在当前线程下，可以通过set()和get()方法来设置和获取值

## ThreadLocal

### 概念
- 线程本地变量，为每个线程都创建一个变量的独立副本，当每个线程访问ThreadLocal中的副本变量时，实际操作的是各自线程的内部副本，以达到线程隔离的效果，可以有效防止线程安全问题

### 使用场景
- **数据库连接管理**: 数据库连接池可以使用ThreadLocal来管理连接，保证每个线程都使用同一个数据库连接。
- **事务管理**: 其实就是通过ThreadLocal使得每个线程只有一个数据库连接，从而保证事务回滚是同一个连接而不会出现错误，其实数据库事务回滚就是建立在同一个数据库连接上的，这样也是为了自治。
- **请求上下文数据存储（最常见)**: 除了用户信息，还可以是请求id、用户会话session、cookie等，可以在整个调用链中进行传递，避免了使用方法参数显式传递

### 实现原理是什么
- ThreadLocal本身并不存储数据，是通过Thread类中的ThreadLocalMap中的Entry(虽然是在Thread中的一个字段，但是这个类是ThreadLocal中的一个静态内部类)来存储数据，其中key是指向创建的一个ThreadLocal对象的弱引用，value是要被存储的变量副本

### ThreadLocal内存泄露问题原因及如何解决
- **原因**:
    - 当ThreadLocal对象没有外部的强引用时会被垃圾回收，但由于值是强引用，仍然保存在ThreadLocalMap中，这时候由于key变为null，所以导致无法被回收，造成内存泄漏
- **那为什么key还要设计成弱引用？**
    - 同样是为了防止内存泄漏，假如是设计成了强引用，那么即使外部没有其他引用指向这个ThreadLocal对象，ThreadLocalMap的key还是通过强引用指向它，这样那么这个对象就和Thread对象，即当前线程是同样的生命周期，在线程池等有线程复用的场景下导致无法被回收，造成了内存泄漏。
- **弱引用**: ThreadLocalMap的键是ThreadLocal实例对象的弱应用(WeakReference)
- **强应用**: 对应的value是强引用
- **如何解决**: 手动或者使用finally块调用ThreadLocal实例对象的remove()方法
    - （其实在ThreadLocal中的某些方法中也会自动删除Entry,比如说在扩容重新hash时,发现key为null时则设置这个Entry的值为null，以便于垃圾回收）

### ThreadLocalMap结构
- 通过调用set()、get()方法设置和获取数据，其中set()方法中是根据Thread.currentThread()方法获取当前线程对象，再通过ThreadLocalMap的实例对象进行赋值。

### 父子线程如何共享数据
- 使用InheritableThreadLocal，需要注意的是：子线程继承的是父线程变量的初始值，如果在子线程中修改了变量的值，不会影响父线程的变量值。同样，父线程中对变量值的修改，子线程也无法感知（除非在子线程启动之前）。其实就是在子线程创建的时候是直接从父线程那里copy过来的副本，创建后就不会相互影响了

## JMM(Java内存模型)

### 如何理解Java内存模型？

## 锁

## 并发工具类

## 线程池

## 并发容器和框架
# 数据表示
## 进制转换
**十进制 转 其他进制 (整数除基取余，小数乘基取整):**
    - **整数部分:** 用十进制数反复除以目标进制的基数，每次记下余数，直到商为0，然后把余数**倒序**排列。
    - **小数部分:** 用十进制小数反复乘以目标进制的基数，每次记下整数部分，用剩下的小数继续乘，直到小数部分为0或达到所需精度，然后把整数部分**顺序**排列。
    - **例子:**
        - 十进制 $(25)_{10}$ 转二进制:
            - 25 / 2 = 12 ... 余 1
            - 12 / 2 = 6 ... 余 0
            - 6 / 2 = 3 ... 余 0
            - 3 / 2 = 1 ... 余 1
            - 1 / 2 = 0 ... 余 1
            - 倒序：$(11001)_2$
        - 十进制 $(0.625)_{10}$ 转二进制:
            - 0.625 * 2 = 1.25 ... 取整 1
            - 0.25 * 2 = 0.5 ... 取整 0
            - 0.5 * 2 = 1.0 ... 取整 1
            - 顺序：$(0.101)_2$
## 码制
这里有一个很重要的概念叫**“机器字长”**，题目中说是8位。你可以把它想象成一个固定长度的“格子”或者“容器”，用来存放一个二进制数。8位的机器字长意味着这个容器固定是8个二进制位（bit）的长度。

对于带符号数，我们通常会用最高位（最左边那位）来表示**符号位**：

- 0 表示正数
- 1 表示负数

剩下的位则用来表示**数值位**（或叫幅度位）。

**1. 原码 (Original Code)**

- **是什么:** 最直观的表示方法。最高位是符号位，其余位是数值的绝对值的二进制表示。
- **为什么:** 容易理解和转换，将十进制数转换为二进制后，直接加上符号位即可。
- **例子 (-19, 8位):**
    - 先看绝对值：|-19| = 19。
    - 将19转换为二进制：19 = 16 + 2 + 1 = 2⁴ + 2¹ + 2⁰。所以19的二进制是 10011。
    - 机器字长是8位，除去1位符号位，还有7位数值位。10011只有5位，需要在前面补0凑足7位：0010011。
    - 因为是-19（负数），符号位是1。
    - 所以，-19 的8位原码是：**1 0010011** (符号位 + 7位数值位)。

**2. 反码 (Inverse Code)**

- **是什么:**
    - 正数的反码：与原码相同。
    - 负数的反码：在原码的基础上，符号位不变（仍为1），其余各位（数值位）取反（0变1，1变0）。
- **为什么:** 反码主要作为补码计算的中间步骤。早期计算机也用反码进行加法运算，但会遇到“0”有两种表示（+0和-0）以及跨越零点运算不方便的问题。
- **例子 (-19, 8位):**
    - -19 的8位原码是 1 0010011。
    - 符号位不变，仍是1。
    - 数值位 0010011 取反，得到 1101100。
    - 所以，-19 的8位反码是：**1 1101100**。

**3. 补码 (Complement Code)**

- **是什么:**
    - 正数的补码：与原码、反码相同。
    - 负数的补码：在反码的基础上，将末位（最低位）加1。如果在加1过程中有进位，则向前进位。
- **为什么:** **补码是计算机中进行加减运算的主要方式。** 使用补码可以将减法运算转化为加法运算，简化了硬件设计。例如，计算 A - B 可以转化为计算 A + (-B) 的补码。补码解决了反码中 +0 和 -0 表示不唯一的问题，并且能正确处理跨越零点的加减法。
- **例子 (-19, 8位):**
    - -19 的8位反码是 1 1101100。
    - 在反码末位加1：
```text
  1 1101100 (反码)
+         1
----------
  1 1101101 (补码)
```
    - 所以，-19 的8位补码是：**1 1101101**。

**4. 移码 (Shift Code)**

- **是什么:** 移码通常用于表示浮点数的阶码（指数部分），以方便比较大小。它的定义是：**移码 = 真值 + 偏移量 (Bias)**。对于一个 n 位的二进制数，常用的偏移量是 2^(n-1)。
- **为什么:** 移码使得所有数值的表示都变成了非负数，并且数值越大，移码的二进制表示也越大，这样可以直接比较移码的二进制串来判断原数值的大小，这在浮点数运算中非常方便。
- **例子 (-19, 8位):**
    - 机器字长 n=8 位。
    - 偏移量 Bias = 2^(8-1) = 2⁷ = 128。
    - 移码 = 真值 + 偏移量 = -19 + 128 = 109。
    - 将109转换为8位二进制：109 = 64 + 32 + 8 + 4 + 1 = 2⁶ + 2⁵ + 2³ + 2² + 2⁰。所以109的二进制是 1101101。
    - 转换为8位二进制：前面补0，得到 **01101101**。
    - **或者，更简单的方法：** 将补码的符号位取反即可得到移码（其他位不变）。-19 的8位补码是 1 1101101。将符号位1取反变成0，得到 **0 1101101**。这两种方法结果一致。
    - 所以，-19 的8位移码是：**0 1101101**。
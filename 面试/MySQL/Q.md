# 基础
## MySQL性能差的原因
- 为使用索引进行优化
- 查询数据量过多（如全表扫描）
- CPU等硬件资源瓶颈
- SQL语句过于复杂
### Q 
- 使用索引优化
- 添加Redis等缓存
---
## 多表合并查询
1. **Q: 内连接和左外连接有什么区别？举例说明。**
    - **A:** 内连接只返回两个表都匹配的行（交集），左外连接返回左表所有行以及右表匹配的行（左表为主）。举例：查询“哪些客户下过订单”用内连接；查询“所有客户及其订单（即使没下过订单）”用左外连接。
2. **Q: 什么时候用右外连接？它和左外连接能互相转换吗？**
    - **A:** 右外连接以右表为主，返回右表所有行及左表匹配行。例如，查询“所有订单及其对应客户（即使客户不存在）”。左右外连接可以互相转换，只需交换 FROM 和 JOIN 后面的表位置即可。
3. **Q: 交叉连接有什么用？在实际中常用吗？**
    - **A:** 交叉连接返回笛卡尔积，通常不直接用于常规数据查询，因为它结果集巨大。常见用途：生成所有可能的组合（如生成所有商品和所有仓库的组合）、测试数据生成。
4. **Q: 如何优化 JOIN 操作的性能？**
    - **A:**
        - **在连接列上创建索引：** 这是最重要的优化手段。
        - **选择合适的连接类型：** 避免不必要的全表扫描。
        - **优化连接顺序：** 数据库会尝试优化，但有时手动调整 FROM 后面的表顺序（小表在前）可能有效。
        - **减少连接的表数量：** 如果可能，避免连接过多表。
        - **使用小表驱动大表：** 在某些场景下，让结果集较小的表先进行筛选，再与大表连接。
5. **Q: 为什么 MySQL 不直接支持 FULL OUTER JOIN？如何模拟？**
    - **A:** MySQL 早期版本设计如此。模拟方法是使用 LEFT JOIN 和 RIGHT JOIN 的结果集通过 UNION 操作合并。UNION 会自动去重。

![[sql.svg]]
## 三大范式
1. **第一范式 (1NF)：**
    - **原理：** 确保数据库表中的每一列都是 **原子性的**，不可再分。
    - **比喻：** 就像你的 Excel 表格里，一个单元格不能包含多个值。比如，“联系电话”列不能同时写“家里电话: 123, 手机: 456”，而是应该拆分成“家里电话”和“手机”两列，或者更进一步，创建一个单独的“联系方式”表。
    - **要求：** ==每列的值都是不可分割的最小单元。==
    - **示例（不符合 1NF）：** 一个“学生课程成绩”表，其中有一列是“课程列表”，值为“数学, 物理, 英语”。
    - **示例（符合 1NF）：** 将“课程列表”拆分成多行，每行只包含一门课程的信息。
2. **第二范式 (2NF)：**
    - **原理：** 在满足 1NF 的基础上，非主键列必须 **完全依赖于主键**，而不是主键的一部分。
    - **比喻：** 就像你的 Excel 表格，如果你的主键是“学号 + 课程ID”，那么学生的姓名、班级等信息（非主键列）应该只依赖于“学号”（主键的一部分），而不是同时依赖于“学号 + 课程ID”。如果学生姓名依赖于“学号 + 课程ID”，那就意味着同一个学生选不同课时，他的姓名可能会重复存储，且修改名字时需要在多处修改。
    - **要求：** 满足 1NF；非主键列必须完全函数依赖于主键。
    - **示例（不符合 2NF）：** “学生选课成绩”表 (学号, 课程ID, 学生姓名, 课程名称, 成绩)。主键是 (学号, 课程ID)。学生姓名只依赖于学号，课程名称只依赖于课程ID，它们没有完全依赖于联合主键 (学号, 课程ID)。
    - **示例（符合 2NF）：** 将表拆分成三个表：
        - `学生表` (学号, 学生姓名, 班级) - 主键：学号
        - `课程表` (课程ID, 课程名称) - 主键：课程ID
        - `选课成绩表` (学号, 课程ID, 成绩) - 主键：(学号, 课程ID)，外键：学号引用学生表，课程ID引用课程表。 这样，学生姓名只存储在学生表中，课程名称只存储在课程表中，避免了冗余和更新异常。
3. **第三范式 (3NF)：**
    - **原理：** 在满足 2NF 的基础上，非主键列之间 **不能存在传递依赖**(同一个表中存在其他主键依赖)。也就是说，==非主键列不能依赖于另一个非主键列。==
    - **比喻：** 就像你的 Excel 表格，如果你的主键是“学号”，非主键列有“班级编号”和“班主任姓名”。如果班主任姓名只依赖于班级编号（而不是直接依赖于学号），那么就存在传递依赖：学号 -> 班级编号 -> 班主任姓名。这意味着同一个班级的所有学生都会重复存储班主任姓名，且班主任换人时需要在多处修改。
    - **要求：** 满足 2NF；任何非主键列都不对非主键列具有传递依赖。
    - **示例（不符合 3NF）：** 在符合 2NF 的 `学生表` 中 (学号, 学生姓名, 班级编号, 班主任姓名)。主键是学号。班主任姓名依赖于班级编号，班级编号依赖于学号 (学号 -> 班级编号 -> 班主任姓名)。
    - **示例（符合 3NF）：** 将表拆分成两个表：
        - `学生表` (学号, 学生姓名, 班级编号) - 主键：学号，外键：班级编号引用班级表。
        - `班级表` (班级编号, 班主任姓名) - 主键：班级编号。 这样，==班主任姓名只存储在班级表中，避免了冗余和更新异常。==
---
1. **Q: 什么是数据库三大范式？各自解决什么问题？**
    
    - **A:** 范式是数据库设计原则，用于减少冗余和异常。1NF 要求列原子化；2NF 要求非主键完全依赖主键；3NF 要求非主键无传递依赖。分别解决列不可分、部分依赖、传递依赖带来的冗余和异常。
2. **Q: 为什么有时要“反范式”设计？会带来什么问题？**
    
    - **A:** 反范式是为了提高查询性能，通过增加冗余来减少 JOIN 操作。例如，在订单表中存储冗余的客户姓名，查询时无需连接客户表。问题：增加数据冗余、更新异常风险、维护成本高。提示：在面试中，强调“范式与性能的权衡”。
3. **Q: 如何判断一个表是否符合某个范式？**
    
    - **A:** 检查是否满足该范式及之前所有范式的要求。例如，判断是否符合 3NF，先看是否符合 1NF、2NF，再看是否存在传递依赖。
4. **Q: 数据库设计到哪个范式比较合适？**
    
    - **A:** 通常到 3NF 是一个很好的平衡点，既减少了冗余，又不会导致表过多、连接过于复杂。BCNF 更严格，但在一些场景可能引入新的复杂性。
5. **Q: 在实际项目中，你是如何进行数据库设计的？**
    
    - **A:** （结合范式和实际经验回答）先进行需求分析，识别实体和关系 -> 遵循范式原则设计表结构（通常到 3NF）-> 考虑业务场景和性能需求，可能进行适当的反范式优化 -> 定义主键、外键、索引 -> 进行数据库建模和评审。
## IN和EXISTS子查询
>这种查询一般只是判断数据是否存在的查询方法，要得到复杂的数据还是使用`join`合并查询
1. **`IN` 的原理：**
    - **执行过程：** 通常情况下，数据库会==先执行子查询，生成一个结果集列表==（例如，所有下过订单的客户 ID 列表）。然后，数据库遍历外层查询的每一行，检查该行中用于匹配的列值（例如，客户 ID）是否存在于子查询生成的结果集列表中，存在则添加到返回结果中。
    - **实例：** 就像你拿到一份“所有下过订单的客户 ID”的清单（子查询结果集），然后挨个核对“客户名单”上的每一个客户，看看他们的 ID 是否在你的清单上。如果在，就把这个客户的信息挑出来。
    - **特点：** 子查询会执行一次，生成一个完整的列表。适用于子查询结果集较小的情况。
2. **`EXISTS` 的原理：**
    - **执行过程：** `EXISTS` 子查询通常是 **关联子查询**。数据库会==遍历外层查询的每一行。对于外层查询的每一行，都会执行一次子查询。子查询会判断是否存在与当前外层查询行相关联的记录。==只要子查询找到匹配的 **第一行**，就会返回 TRUE，外层查询继续处理下一行；如果子查询遍历完所有相关记录都没有找到匹配的行，就返回 FALSE。
    - **实例：** 就像你拿着“客户名单”上的第一个客户，去“订单列表”里找“这个客户有没有订单”。找到了一个订单？好的，不用再找了，这个客户符合条件，把他挑出来，然后处理下一个客户。如果找遍了都没找到这个客户的订单，就放弃这个客户，处理下一个。
    - **特点：** 子查询会根据外层查询的行数执行多次。适用于子查询结果集较大，或者子查询本身包含复杂的逻辑判断（如 JOIN、WHERE）的情况。
### Q
1. **Q: IN 和 EXISTS 的主要区别是什么？**
    
    - **A:** `IN` 是将外层查询的值与子查询的结果集进行匹配，子查询通常先执行一次；`EXISTS` 是判断子查询是否返回行，子查询通常是关联子查询，对外层查询的每一行执行一次。
2. **Q: 什么时候优先使用 IN，什么时候优先使用 EXISTS？**
    
    - **A:**
        - **IN 优先：** **子查询结果集较小**，或者子查询不依赖外层查询的任何列。
        - **EXISTS 优先：** 子查询结果集较大，或者子查询依赖外层查询的列（关联子查询），且外层查询结果集相对较小。
        - **最准确判断：** 使用 `EXPLAIN` 分析查询计划，看哪种写法的执行计划更优。
3. **Q: EXISTS 后面的 SELECT 1 是什么意思？可以写 SELECT * 吗？**
    
    - **A:** `SELECT 1` 是一种约定俗成的写法，表示“只要找到任何一行就行，具体值是多少不重要”。写 `SELECT *` 也可以，但 `SELECT 1` 效率更高，因为它不需要实际去检索列的值。
4. **Q: IN 和 JOIN 能互相替代吗？有什么优缺点？**
    - **A:** 在很多情况下可以互相替代。
        - **JOIN 优点：** 可以返回两个表中的所有列，更灵活；优化器通常对 JOIN 有更好的优化。
        - **JOIN 缺点：** 在某些场景下，如果只关心是否存在，JOIN 可能会产生冗余的中间结果集，不如 EXISTS 直接。
        - **IN 优点：** 语法简洁，易于理解。
        - **IN 缺点：** 在大数据集上性能可能不如 EXISTS 或优化后的 JOIN。
        - **EXISTS 优点：** 在大数据集上可能性能更好，尤其适合判断是否存在。
        - **EXISTS 缺点：** 只能判断是否存在，不能直接获取子查询中的其他列信息。
5. **Q: IN 子查询中如果返回 NULL 值会有什么影响？**
    - **A:** 如果子查询返回的列表包含 NULL 值，那么 `WHERE column IN (..., NULL, ...)` 这样的条件可能会导致意外的结果。因为 `value IN (..., NULL, ...)` 对于任何非 NULL 的 `value` 都会判断为 UNKNOWN（未知），导致无法匹配。而 `WHERE column NOT IN (..., NULL, ...)` 对于任何值都会判断为 UNKNOWN，导致没有任何行返回。这是一个常见的陷阱。**而 `EXISTS` 子查询通常不受 NULL 值影响。**
